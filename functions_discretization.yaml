%YAML 1.2
---
aggregate_functions:
   -
    name: "cut"
    description: >
      Categorises values into regular intervals

      Bins may refer to the exact number of equal-width partitions or,
      bin-edges allowing non-uniform width.

      Options specifies including either the left, right or both intervals.
    impls:
      - args:
          - name: x
            value: List<i16>
          - name: bins
            value: List<fp32>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i32>
          - name: bins
            value: List<fp32>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i64>
          - name: bins
            value: List<fp64>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<fp32>
          - name: bins
            value: List<fp32>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<fp64>
          - name: bins
            value: List<fp64>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<i16>
          - name: bins
            value: List<List<fp32>>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i32>
          - name: bins
            value: List<List<fp32>>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<i32>>
      - args:
          - name: x
            value: List<i64>
          - name: bins
            value: List<List<fp64>>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<fp32>
          - name: bins
            value: List<List<fp32>>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<fp64>
          - name: bins
            value: List<List<fp64>>
          - name: ordered
            value: bool       
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
        return: List<List<fp64>>
   -
    name: "bin"
    description: "Categorises values into bins"
    impls:
      - args:
          - name: x
            value: List<i16>
          - name: bins
            value: i16    
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i32>
          - name: bins
            value: i32      
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i64>
          - name: bins
            value: i64  
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<fp32>
          - name: bins
            value: i64  
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<fp64>
          - name: bins
            value: i64  
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<i16>
          - name: bins
            value: List<fp32>
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i32>
          - name: bins
            value: List<fp32>
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp32>>
      - args:
          - name: x
            value: List<i64>
          - name: bins
            value: List<fp32>
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<fp32>
          - name: bins
            value: List<fp32>
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp64>>
      - args:
          - name: x
            value: List<fp64>
          - name: bins
            value: List<fp32>
        options:
          inclusive:
            values: [LEFT_INCLUSIVE, RIGHT_INCLUSIVE, ALL_INCLUSIVE]
          encode:
            values: [ONEHOT, ONEHOT_DENSE, ORDINAL]
          strategy:
            values: [UNIFORM, QUANTILE-UNIFORM, QUANTILE-NORMAL, KMEANS]
        return: List<List<fp64>>
   -
    name: "binarizer"
    description: "Binarize data according to threshold"
    impls:
      - args:
          - name: x
            value: List<i16>
          - name: threshold
            value: fp32    
        return: List<bool>
      - args:
          - name: x
            value: List<i32>
          - name: threshold
            value: fp32    
        return: List<bool>
      - args:
          - name: x
            value: List<i64>
          - name: threshold
            value: fp64    
        return: List<bool>
      - args:
          - name: x
            value: List<fp32>
          - name: threshold
            value: fp32    
        return: List<bool>
      - args:
          - name: x
            value: List<fp64>
          - name: threshold
            value: fp64  
        return: List<bool>
   -
    name: "label_binarizer"
    description: "label data in binary for a one-vs-all fashion"
    impls:
      - args:
          - name: x
            value: List<any>
          - name: neg_label
            value: i32   
          - name: pos_label
            value: i32    
        return: List<List<i32>>
   -
    name: "label_encoder"
    description: "encode with value from 0 to num_classes-1"
    impls:
      - args:
          - name: x
            value: List<any> 
        return: List<i32>
        options:
          order:
            values: [NONE, ASCENDING, DESCENDING]
   -
    name: "multi_label_binarizer"
    description: "labelling iterable of iterables"
    impls:
      - args:
          - name: x
            value: List<List<any>> 
        return: List<List<i32>>
   -
    name: "multi_label_binarizer"
    description: "labelling iterable of iterables"
    impls:
      - args:
          - name: x
            value: List<List<any>> 
        return: List<List<i32>>
   -
    name: "dummy_feature"
    description: "add a dummy feature in a dataset"
    impls:
      - args:
          - name: x
            value: any 
          - name: axis
            value: i32 
          - name: value 
            value: fp64
        return: any
